 /*
       PacocaTeam
       Alunos : 
                Daniel(21201910)
                Denys(21200320)
*/

import java.util.List;
import java.util.ArrayList;
import java.util.Iterator;

class NDesig {
        String nome;
        boolean vec;
        public NDesig(String n, boolean v) {
                nome = n;
                vec = v;
        }
        public String getNome() {
                return nome;
        }
        public boolean vetor() {
                return vec;
        }
}

class NTipo {
        String tipo;
        boolean vec;
        public NTipo(String t, boolean v) {
                tipo = t;
                vec = v;
        }
        public String getTipo() {
                return tipo;
        }
        public boolean vetor() {
                return vec;
        }
}

COMPILER MicroPortugol

	private Tab ts;
	private Obj ofuncAtual;
	private Operand op;

	private Code objCode;
	
	private Struct getTipo(String tipo, boolean vec) { 
		Obj o = ts.buscar(tipo);
		Struct st = o.tipo;
		if (vec) st = new Struct(Struct.Vetor, o.tipo);
		return st;	
	}

	public void erro(String msg) {
		errors.SemErr(t.line, t.col, msg);
	}

	public int toInteger(String str){
		return Integer.parseInt(str);
	}

	public void debug(String str){
		System.out.println(str);
	}

CHARACTERS
	semAspas 	= ANY - '"'.
	letra 		= "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_".
	digito 		= "0123456789".

TOKENS
	id 		    = letra {letra | digito}.
	strConst 	= '"' {semAspas} '"'.
	num 		= ['-'] digito { digito } .

PRAGMAS
	option = "$d".	(. ts.dump(); .)

COMMENTS FROM "/*" TO "*/" NESTED

IGNORE '\r' + '\n' + '\t'

PRODUCTIONS


/* 
 * O escopo universo foi modelado de forma que contenha um conjunto de variaveis globais,
 * constantes ou procedimentos e apenas UM bloco principal, seguindo as restricoes
 * definidas pela linguagem Algol 68
*/

MicroPortugol                           (. 
										   ofuncAtual = null; 
                                           ts = new Tab(this);
                                           ts.abrirEscopo("Global");
                                        .) 


= "algoritmo" id 
        {declaracao_var| 
         declaracao_const|
         bloco_procedimento				(.objCode.setDataSize(ts.escopoAtual.nVars);.)

        } 
        bloco_principal                (. ts.fecharEscopo(); .)
        .

/* 
 * "declaracao_var" não termina com ; pois pode pertencer tanto a declaracao global quanto
 * a regra "instrucoes" e para efeitos de simplificacao tal regra foi definada terminando
 * com ";". Isso foi necessario para evitar apenas reconhecer ";;" na regra instrucoes.  
*/


// Bloco de declaracao de variaveis e constantes

declaracao_var                          (.  
                                           ArrayList<String> nomeVariaveis 
                                                = new ArrayList();
                                           NTipo ntipo;
                                        .)

 = 
"variavel"								(. debug("variavel"); .)	
id                                      (. nomeVariaveis.add(t.val); .)  
{","
 id                                     (. nomeVariaveis.add(t.val); .) 
} 
":" 
tipo<out ntipo>                         (. Struct st = getTipo(ntipo.getTipo(),
                                                ntipo.vetor());
											debug(ntipo.getTipo());
                                           if (st == ts.semTipo)
                                                erro("A variável não pode ter tipo desconhecido");
                                                 
                                           Iterator iter = nomeVariaveis.iterator();
										   debug("npars++");
										   //ofuncAtual.nPars  = nomeVariaveis.size();
                                           while (iter.hasNext()) {
                                                ts.inserir(Obj.Var, iter.next().toString(), st);
                                           }
                                        .)
                                                 
";"										.


tipo<out NTipo ntipo>                   (. boolean vet = false; 
                                           String tip;
                                        .)
=                                       
"inteiro"                               (. tip = t.val; .)
[ "[" "]"                                (. vet = true; .) (. debug(tip + " eh Vetor");.)
]                                       (. ntipo = new NTipo(tip, vet); .)
.      

declaracao_const                        (. 
                                           Obj obj;
                                        .)   
= "constante"							(. debug("const"); .) 
        id                              (. obj = ts.buscar("inteiro");
                                           obj = ts.inserir(Obj.Const, t.val, obj.tipo); 
                                        .) 
        "=" 
        num                             (. obj.val = toInteger(t.val); .)
        ";"
        .

// Funcoes e parametros
parametros  (. NTipo ntipo; .) 
	=
id ":" 
	tipo<out ntipo> 
	{"," 
		id 
			":"
		tipo<out ntipo>
	}.
parametros_passados<Operand op>			(. Operand passados; .)
= "(" 
										(. if(op.cat != Operand.Func){
												erro("nao eh uma funcao ");
												op.obj = ts.semObj;
											}
											int preais = 0;
											int pdecl = op.obj.nPars;
											Obj fp = op.obj.locais;
										.)
	[expressao<out passados>			(. objCode.load(passados);
											preais++;
											if( fp != null){
												if(!passados.tipo.assinalavelPara(fp.tipo))
													erro("Tipo de paramentro incompativel");
												fp = fp.prox;
											}
										.)
	
	{"," expressao<out passados>		(.objCode.load(passados);
										  preais++;
										  if (fp != null){
											if(!passados.tipo.assinalavelPara(fp.tipo))
												erro("Tipo de paramentro incompativel");
											}											
										.)
										  
	 } ]								(.if (preais > pdecl)
											erro("quantidade de paramentros passados maior do que os declarados");
										  else if(preais < pdecl)
											erro("quantidade de paramentros passados menor do que os declarados");
										.)
	 
	 ")"
	 
	 .



bloco_procedimento                      (. NTipo ntipo; 
                                           String nome;
                                           boolean tipoInformado = false;
                                        .)
= "procedimento" 
id                                      (. nome = t.val; 
                                           ofuncAtual = ts.inserir(Obj.Func,
                                           nome,
                                           getTipo("void", false));
                                           ts.abrirEscopo("Func " + nome); 
                                        .) 
"(" 
[parametros] 
")" 
[":" tipo<out ntipo>                   
] 
"inicio"							 (. ofuncAtual.end = objCode.getPC();
                                   objCode.put(objCode.enter);
									objCode.put(ofuncAtual.nPars);
                                   int pcvars = objCode.getPC();
                                   objCode.put(0);
                                .)

                                  
 instrucoes						 (. objCode.put(pcvars, ts.escopoAtual.nVars);
                                   if (ofuncAtual.tipo == ts.semTipo) {
                                        objCode.put(objCode.exit);
                                        objCode.put(objCode.return_);
                                   } else {
                                        // fim da funcao alcancado
                                        // sem instrucao return
                                        objCode.put(objCode.trap);
                                        objCode.put(1);
                                   }						
								.)
"fim"   (. debug("fim"); .)                                (. ofuncAtual.locais = ts.escopoAtual.locais;
                                           ts.fecharEscopo();
                                        .)
.

retorno = "retorne" [
		
		expressao<out op>
		
		] ";". 


bloco_principal                         (. ofuncAtual = ts.inserir(Obj.Func,
                                           "main", getTipo("void", false));
                                           ts.abrirEscopo("Func main");
										   objCode = new Code();
										   objCode.setMainPC();
                                        .)

= "inicio"						 (. ofuncAtual.end = objCode.getPC();
                                   objCode.put(objCode.enter);
                                   objCode.put(ofuncAtual.nPars);
                                   int pcvars = objCode.getPC();
                                   objCode.put(0);
                                .)
  instrucoes					(. objCode.put(pcvars, ts.escopoAtual.nVars);.)
  "fim"                                 (. ofuncAtual.locais = ts.escopoAtual.locais;
                                           ts.fecharEscopo();
										   objCode.put(objCode.exit);
										   objCode.put(objCode.return_);
                                        .)
  .

comando									(. Operand op = null; .)
	= 

	(
		declaracao_var (. debug("dec_var");.)(.objCode.setDataSize(ts.escopoAtual.nVars);.)


		| 
		repeticao_def (. debug("rep");.)

		| 
		condicional_def (. debug("cond");.)

		| 
		io_def (. debug("io");.)

		| 
		designador<out op> (. debug("desig");.)

						(
						assinalamento<op> (. debug("assina");.)

						| 

						parametros_passados<op> (. debug("param");.)

						) 
					";" | 
					retorno
					).


// Definicao de instrucoes e suas respectivas estruturas

instrucoes								
	= 
	{
	comando								(. debug("comando");.)
	}.


assinalamento<Operand op1>								(. Operand op2 = null; .)	
	=	"="	
			expressao<out op2>								(. if(op2.tipo.assinalavelPara(op1.tipo))
																	   objCode.assign(op1, op2);
															   else
																   erro("tipos incompativeis");
															.)
																	
																	
	.
repeticao_def = para_def | enquanto_def | repita_def.
para_def = 
	"para"
		id "=" 
			expressao<out op> 
			"ate" 
			expressao<out op> 
			[
				"passo" 
					expressao<out op>
			] 
			"faca" 
				instrucoes 
	"fimpara"
[";"].

enquanto_def = "enquanto" condicao "faca" instrucoes "fimenquanto" [";"].
operador_relacional = "!=" | ">" | "<" | ">=" | "<=" | "==".

repita_def = "repita" instrucoes "ate" condicao ";".

// Comandos condicionais

condicional_def = se_def | caso_def.

se_def = "se" condicao "entao" instrucoes ["senao" instrucoes] "fimse" [";"]. 
caso_def = "caso" designador<out op> caso_seja_def {caso_seja_def} "outrocaso" ":" instrucoes "fimcaso".
caso_seja_def 
	= 
		"seja" 
				expressao<out op> 
		"faca" 
				instrucoes.

condicao 
	= 
		expressao<out op> 
		
		operador_relacional 
		
		expressao<out op>.


// Funcoes de entrada e saida
io_def = escreva_def | leia_def.

// -- leia(n); -> se n for invalido, entao retorna 0.
leia_def = "leia"	(. debug("leia");.)
 "(" designador<out op> ")" ";".
escreva_def = "escreva"  (.debug("escreva");.)
			"(" (strConst | 
				designador<out op> 
				[
					parametros_passados<op>
				]
				) 

			{"," 
				(strConst | 
				designador<out op> 
				[
					parametros_passados<op>
				]
				)
			} 
			")" ";".
// Tratamento de expressoes


expressao<out Operand op>			(. Operand op2; int operador; op = null; .)

	= 	termo<out op>				(. if(op.tipo != ts.tipoInt)
											erro("Operando de tipo nao-inteiro");
									.)
	{
		(
			 "+"					(. operador = objCode.add; .)
			|"-"					(. operador = objCode.sub; .)
		)							(. objCode.load(op); .) 
			termo<out op2>			(. objCode.load(op2); .)	
									(. if(op.tipo != ts.tipoInt || op2.tipo != ts.tipoInt)
											erro("Operando de tipo nao-inteiro");
										objCode.put(operador);
									.)

	}.

termo<out Operand op>				(. Operand op2; int operador; op = null;.)
	= 
		fator<out op>				
		{
			(
				 "*"				(. operador = objCode.mul; .)
				|"/"				(. operador = objCode.div; .)
				|"%"				(. operador = objCode.rem; .)
			)						(. objCode.load(op); .) 
									

			fator<out op2>			(. objCode.load(op2); .)
									(. if(op.tipo != ts.tipoInt || op2.tipo != ts.tipoInt)
											erro("Operando de tipo nao-inteiro");
										objCode.put(operador);
									.)

		}.


fator<out Operand op>				(.op=null; .) 

	= 
		num								(.op = new Operand(toInteger(t.val)); .) 
		| designador<out op>				
		[
			parametros_passados<op>		(.
			
										   if (op.tipo == ts.semTipo)
											   erro("função de tipo void usada em expressão");
										   if (op.obj == ts.objTamVetor)
											   objCode.put(objCode.arraylength);
										   else {
											   objCode.put(objCode.call);
											   objCode.put2(op.end);
										   }
										   op.cat = Operand.Stack;
										
										.)
		] | 
					
		"(" expressao<out op> ")" | 		
		aloc_vetor<out op>.				

aloc_vetor<out Operand op> =  
	"novo"					(. op = null; List<Integer> lista = null; NTipo ntipo; .)
        "inteiro"						(. Obj obj = ts.buscar("inteiro"); .)
	(
	"["
		expressao<out op>				(. if( op.tipo != ts.tipoInt)
												erro("A quantidade de elementos do vetor deve ser uma variavel de tipo inteira");
										.) 
	"]" | 
	"{"
		num								(. lista.add(toInteger(t.val)); .)
			{
				"," 
					num					(. lista.add(toInteger(t.val)); .)
			} 
	"}"									(. op = new Operand(lista.size()); .)
	)									(. op.tipo = new Struct(Struct.Vetor, obj.tipo); .)
	.



/* 
 * Existe um grande problema em relacao ao reconhecimento de designadores e
 * chamada de funcoes (ambas as regras comecam com o token "id". A maneira a qual a
 * ambiguidade foi solucionada consiste na seguinte producao utilizada na regra "comando"
 * : designador (assinalamento | parametros_passados) 

 * Incoerencias como "funcao[]();" serao tratados semanticamente

*/

//O designador indica uma variavel ou um vetor

designador<out Operand op> =							(.String nome; Operand indice = null; .) 
	id													(. nome = t.val;
														   op  = new Operand(ts.buscar(nome));
														.)
											
[ "["													(. objCode.load(op); .)
		expressao<out indice>							(. //objCode.load(indice);	
														 if(op.tipo.cat == Struct.Vetor){
																if(indice.tipo.cat != Struct.Int)
																	erro("O indice deve ser um valor inteiro");
																objCode.load(indice);
																op.cat = Operand.Elem;
																op.tipo =  op.tipo.tipoElemento;
															}else{

																erro("A variavel "+ nome + " nao eh um vetor");

															}
	
	
														.)
	"]"													(. debug("]");.)	
] .										


END MicroPortugol.

